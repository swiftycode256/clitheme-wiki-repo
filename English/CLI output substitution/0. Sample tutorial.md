# A simple tutorial

This article will demonstrate a tutorial of the command-line output substitution feature, including getting output using `clitheme-exec --showchars` and writing substitution rules based on the output.

> To learn more, please read [Writing definition files](1.%20Writing%20definition%20files.md) and [Using clitheme-exec](2.%20Using%20clitheme-exec.md).

## 1. Getting the program output

Let's say we want to customize the output messages of the `clang` compiler. If our test file is `test.c`, we can use `clitheme-exec --showchars clang test.c` to obtain the output including terminal control sequences. When writing substitution rules, we need to consider these terminal control sequences. 

You can use the `--nosubst` option to obtain the original output of the program if you have already applied a theme.

You can use the `--debug` option to add an indicator at the start of each output line. ~~This indicator will indicator whether the output is standard output or standard error (labeled with `o` or `e`).~~

> [!NOTE]
>  `--showchars` and other options must be placed before the command (e.g. `clitheme-exec --showchars --debug clang`)

> [!TIP]
> To learn more, please read [Using clitheme-exec](2.%20Using%20clitheme-exec.md).

```plaintext
$ clitheme-exec --debug --showchars --nosubst clang test.c
o> {{ESC}}[1mtest.c:1:1: {{ESC}}[0m{{ESC}}[0;1;31merror: {{ESC}}[0m{{ESC}}[1munknown type name 'bool'{{ESC}}[0m\r\n
o[ bool *haku(int *a) {\r\n
o[ {{ESC}}[0;1;32m^\r\n
o[ {{ESC}}[0m{{ESC}}[1mtest.c:4:3: {{ESC}}[0m{{ESC}}[0;1;35mwarning: {{ESC}}[0m{{ESC}}[1mincompatible pointer types assigning to 'char *' from 'int *' [-Wincompatible-pointer-types]{{ESC}}[0m\r\n
o[         b=a;\r\n
o[ {{ESC}}[0;1;32m         ^~\r\n
o[ {{ESC}}[0m2 errors generated.\r\n
```

For reference, this is the original output of `clang test.c`:

```plaintext
$ clang test.c
test.c:1:1: error: unknown type name 'bool'
bool *haku(int *a) {
^
test.c:4:3: warning: incompatible pointer types assigning to 'char *' from 'int *' [-Wincompatible-pointer-types]
        b=a;
         ^~
2 errors generated.
```

In this example, we will customize the `unknown type name` and `incompatible pointer types` messages.

## 2. Writing a definition file 

After we obtained the output content, we can start writing the definition file and substitution rules.

### Writing regex expressions for output

We can write **regex substitution rules** for the output. To learn more about regular expressions (regex) and Python's regex syntax, please see [this article](https://docs.python.org/3/howto/regex.html) from Python docs.

To avoid accidentally matching unrelated output content, we will match from the start of the line, including the prefix's filename and line number (e.g. `test.c:1:1:`). However, we don't need to match all of the line's contents, so we can safely ignore the end of the line.

> Let's take this line of output as a example (`{{ESC}}` is used to represent the ASCII Escape character)
> 
> ```plaintext
> {{ESC}}[0m{{ESC}}[1mtest.c:4:3: {{ESC}}[0m{{ESC}}[0;1;35mwarning: {{ESC}}[0m{{ESC}}[1mincompatible pointer types assigning to 'char *' from 'int *' [-Wincompatible-pointer-types]{{ESC}}[0m\r\n
> # Original content:
> test.c:4:3: warning: incompatible pointer types assigning to 'char *' from 'int *' [-Wincompatible-pointer-types]
> ```
> 
> We can use the the following regex pattern to match from the start of the line before the `[-Wincompatible-pointer-types]` part:
> 
> ```plaintext
> (?P<prefix>^({{ESC}}.*?m)*(.+:\d+:\d+:) ({{ESC}}.*?m)*)warning: (?P<esc>({{ESC}}.*?m)*)incompatible pointer types assigning to '(?P<name1>.+)' from '(?P<name2>.+)'
> ```
> 
> - This pattern matches escape sequences as it's necessary. Else, it won't successfully match the output, causing the rule to not apply.
> - This pattern also used named capture groups, which is recommended for simplicity and reducing errors.

After writing the match pattern, we can now define what content we replace with. The substitute pattern references the defined capture groups to preserve some captured content.

```plaintext
\g<prefix>note: \g<esc>incompatible pointer types '\g<name1>' and '\g<name2>', they're so……so incompatible!~
```

The `\g<group>` syntax here places the content matched in capture group named `group` into the content. The `\g<prefix>` preserves the prefix (`test.c:1:1:`), while `\g<name1>` and `\g<name2>` preserves the type name (such as `char *` and `int *`).

### Writing the expressions as substitution rules

We can now write the expression as substitution rules and place them in a definition file, including the `unknown type name` message:

```plaintext
# Define the theme info in the header section (required)
{header}
    # name entry must be defined
    name: clang example theme
    [description]
        clang example theme for demonstration purposes
    [/description]
{/header}

{substrules}
    # Enable "substesc" to replace "{{ESC}}" in content with the ASCII Escape character
    (set_options) substesc
    # Command filter ensures the following substitution rules are only applied in these commands. Recommended for avoiding accidental matches.
    [filter_cmds]
        clang
        clang++
    [/filter_cmds]
        [subst_regex] (?P<prefix>^({{ESC}}.*?m)*(.+:\d+:\d+:) ({{ESC}}.*?m)*)warning: (?P<esc>({{ESC}}.*?m)*)incompatible pointer types assigning to '(?P<name1>.+)' from '(?P<name2>.+)'
            # If you only want this rule to apply when the system locale is English (en_US), you can use "locale[en_US]:"
            # Use "default" if you don't want system locale filters 
            default: \g<prefix>note: \g<esc>incompatible pointer types '\g<name1>' and '\g<name2>', they're so……so incompatible!~
        [/subst_regex]
        [subst_regex] (?P<prefix>^({{ESC}}.*?m)*(.+:\d+:\d+:) ({{ESC}}.*?m)*)error: (?P<esc>({{ESC}}.*?m)*)unknown type name '(?P<type>.+)'
            default: \g<prefix>Error! : \g<esc>unknown type name 'bool', you forgot to d……define it!~ಥ_ಥ        
        [/subst_regex]
{/substrules}
```

#### Content variables

You may have noticed that the two match expressions share the same prefix capture group expression. If you write more of these similar substitution rules, copying and maintaining them altogether can be very troublesome. Therefore, we can use [Content variables](../[Appendix]%20Common%20syntax%20of%20theme%20definition%20files/Content%20variables.md) to solve this problem:

```plaintext
{substrules}
    (set_options) substesc
    # Enable `substvar` to enable content variables
    (set_options) substvar
    [filter_cmds]
        clang
        clang++
    [/filter_cmds]
        # Define the `match_prefix` variable
        setvar[match_prefix]: (?P<prefix>^({{ESC}}.*?m)*(.+:\d+:\d+:) ({{ESC}}.*?m)*)

        # `{{match_prefix}}` in content will be replaced with the content in the `match_prefix` variable
        [subst_regex] {{match_prefix}}warning: (?P<esc>({{ESC}}.*?m)*)incompatible pointer types assigning to '(?P<name1>.+)' from '(?P<name2>.+)'
            default: \g<prefix>note: \g<esc>incompatible pointer types '\g<name1>' and '\g<name2>', they're so……so incompatible!~
        [/subst_regex]
        [subst_regex] {{match_prefix}}error: (?P<esc>({{ESC}}.*?m)*)unknown type name '(?P<type>.+)'
            default: \g<prefix>Error! : \g<esc>unknown type name 'bool', you forgot to d……define it!~ಥ_ಥ        
        [/subst_regex]
{/substrules}
```

> [!TIP]
> To learn more syntax definitions and features, please read [Writing definition files](1.%20Writing%20definition%20files.md).

> [!TIP]
> To learn about features like character substitution, line bounds, and substitution rules options, please read [Available options](../[Appendix]%20Common%20syntax%20of%20theme%20definition%20files/Available%20options.md)

## 3. Applying the definition file

Run the command `clitheme apply-theme <file>` to apply the definition file, and run `clitheme-exec clang test.c` to see the effects. 

You can also use `python3 -m clitheme` and `python3 -m clitheme.exec` commands.

```plaintext
$ clitheme-exec clang test.c
test.c:1:1: Error! : unknown type name 'bool', you forgot to d……define it!~ಥ_ಥ
bool *func(int *a) {
^
test.c:4:3: note: incompatible pointer types 'char *' and 'int *', they're so……so incompatible!~ [-Wincompatible-pointer-types]
        b=a;
         ^~
2 errors generated.
```
